// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by unknown module path version unknown version DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerTokenAuthScopes = "BearerTokenAuth.Scopes"
	CookieAuthScopes      = "CookieAuth.Scopes"
)

// Defines values for CredentialCreationOptionsPublicKeyAttestation.
const (
	CredentialCreationOptionsPublicKeyAttestationDirect     CredentialCreationOptionsPublicKeyAttestation = "direct"
	CredentialCreationOptionsPublicKeyAttestationEnterprise CredentialCreationOptionsPublicKeyAttestation = "enterprise"
	CredentialCreationOptionsPublicKeyAttestationIndirect   CredentialCreationOptionsPublicKeyAttestation = "indirect"
	CredentialCreationOptionsPublicKeyAttestationNone       CredentialCreationOptionsPublicKeyAttestation = "none"
)

// Defines values for CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachment.
const (
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachmentCrossPlatform CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachment = "cross-platform"
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachmentPlatform      CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachment = "platform"
)

// Defines values for CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey.
const (
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKeyDiscouraged CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey = "discouraged"
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKeyPreferred   CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey = "preferred"
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKeyRequired    CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey = "required"
)

// Defines values for CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification.
const (
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerificationDiscouraged CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification = "discouraged"
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerificationPreferred   CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification = "preferred"
	CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerificationRequired    CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification = "required"
)

// Defines values for CredentialCreationOptionsPublicKeyPubKeyCredParamsType.
const (
	CredentialCreationOptionsPublicKeyPubKeyCredParamsTypePublicKey CredentialCreationOptionsPublicKeyPubKeyCredParamsType = "public-key"
)

// Defines values for CredentialRequestOptionsPublicKeyAllowCredentialsType.
const (
	CredentialRequestOptionsPublicKeyAllowCredentialsTypePublicKey CredentialRequestOptionsPublicKeyAllowCredentialsType = "public-key"
)

// Defines values for CredentialRequestOptionsPublicKeyUserVerification.
const (
	CredentialRequestOptionsPublicKeyUserVerificationDiscouraged CredentialRequestOptionsPublicKeyUserVerification = "discouraged"
	CredentialRequestOptionsPublicKeyUserVerificationPreferred   CredentialRequestOptionsPublicKeyUserVerification = "preferred"
	CredentialRequestOptionsPublicKeyUserVerificationRequired    CredentialRequestOptionsPublicKeyUserVerification = "required"
)

// Defines values for PublicKeyCredentialAssertionResponseType.
const (
	PublicKeyCredentialAssertionResponseTypePublicKey PublicKeyCredentialAssertionResponseType = "public-key"
)

// Defines values for PublicKeyCredentialAttestationResponseResponseTransports.
const (
	PublicKeyCredentialAttestationResponseResponseTransportsBle      PublicKeyCredentialAttestationResponseResponseTransports = "ble"
	PublicKeyCredentialAttestationResponseResponseTransportsInternal PublicKeyCredentialAttestationResponseResponseTransports = "internal"
	PublicKeyCredentialAttestationResponseResponseTransportsNfc      PublicKeyCredentialAttestationResponseResponseTransports = "nfc"
	PublicKeyCredentialAttestationResponseResponseTransportsUsb      PublicKeyCredentialAttestationResponseResponseTransports = "usb"
)

// Defines values for PublicKeyCredentialAttestationResponseType.
const (
	PublicKeyCredentialAttestationResponseTypePublicKey PublicKeyCredentialAttestationResponseType = "public-key"
)

// Defines values for WebauthnCredentialsTransports.
const (
	WebauthnCredentialsTransportsBle      WebauthnCredentialsTransports = "ble"
	WebauthnCredentialsTransportsInternal WebauthnCredentialsTransports = "internal"
	WebauthnCredentialsTransportsNfc      WebauthnCredentialsTransports = "nfc"
	WebauthnCredentialsTransportsUsb      WebauthnCredentialsTransports = "usb"
)

// Defines values for ThirdPartyAuthParamsProvider.
const (
	ThirdPartyAuthParamsProviderGithub ThirdPartyAuthParamsProvider = "github"
	ThirdPartyAuthParamsProviderGoogle ThirdPartyAuthParamsProvider = "google"
)

// CookieSession Value `<JWT>` is a [JSON Web Token](https://www.rfc-editor.org/rfc/rfc7519.html)
type CookieSession = string

// CreateUserResponseObject defines model for CreateUserResponseObject.
type CreateUserResponseObject struct {
	// EmailId The ID of the newly created email address
	EmailId *UUID4 `json:"email_id,omitempty"`

	// UserId The ID of the newly created user
	UserId *UUID4 `json:"user_id,omitempty"`
}

// CredentialCreationOptions Options for credential creation with the WebAuthn API
type CredentialCreationOptions struct {
	PublicKey *struct {
		Attestation            *CredentialCreationOptionsPublicKeyAttestation `json:"attestation,omitempty"`
		AuthenticatorSelection *struct {
			AuthenticatorAttachment *CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachment `json:"authenticatorAttachment,omitempty"`
			RequireResidentKey      *bool                                                                            `json:"requireResidentKey,omitempty"`
			ResidentKey             *CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey             `json:"residentKey,omitempty"`
			UserVerification        *CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification        `json:"userVerification,omitempty"`
		} `json:"authenticatorSelection,omitempty"`
		Challenge        *string `json:"challenge,omitempty"`
		PubKeyCredParams *[]struct {
			Alg  *float32                                                `json:"alg,omitempty"`
			Type *CredentialCreationOptionsPublicKeyPubKeyCredParamsType `json:"type,omitempty"`
		} `json:"pubKeyCredParams,omitempty"`
		Rp *struct {
			Id   *string `json:"id,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"rp,omitempty"`
		Timeout *int64 `json:"timeout,omitempty"`
		User    *struct {
			DisplayName *string `json:"displayName,omitempty"`
			Id          *string `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
		} `json:"user,omitempty"`
	} `json:"publicKey,omitempty"`
}

// CredentialCreationOptionsPublicKeyAttestation defines model for CredentialCreationOptions.PublicKey.Attestation.
type CredentialCreationOptionsPublicKeyAttestation string

// CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachment defines model for CredentialCreationOptions.PublicKey.AuthenticatorSelection.AuthenticatorAttachment.
type CredentialCreationOptionsPublicKeyAuthenticatorSelectionAuthenticatorAttachment string

// CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey defines model for CredentialCreationOptions.PublicKey.AuthenticatorSelection.ResidentKey.
type CredentialCreationOptionsPublicKeyAuthenticatorSelectionResidentKey string

// CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification defines model for CredentialCreationOptions.PublicKey.AuthenticatorSelection.UserVerification.
type CredentialCreationOptionsPublicKeyAuthenticatorSelectionUserVerification string

// CredentialCreationOptionsPublicKeyPubKeyCredParamsType defines model for CredentialCreationOptions.PublicKey.PubKeyCredParams.Type.
type CredentialCreationOptionsPublicKeyPubKeyCredParamsType string

// CredentialRequestOptions Options for assertion generation with the WebAuthn API
type CredentialRequestOptions struct {
	PublicKey *struct {
		AllowCredentials *[]struct {
			Id   *string                                                `json:"id,omitempty"`
			Type *CredentialRequestOptionsPublicKeyAllowCredentialsType `json:"type,omitempty"`
		} `json:"allowCredentials,omitempty"`
		Challenge        *string                                            `json:"challenge,omitempty"`
		RpId             *string                                            `json:"rpId,omitempty"`
		Timeout          *int64                                             `json:"timeout,omitempty"`
		UserVerification *CredentialRequestOptionsPublicKeyUserVerification `json:"userVerification,omitempty"`
	} `json:"publicKey,omitempty"`
}

// CredentialRequestOptionsPublicKeyAllowCredentialsType defines model for CredentialRequestOptions.PublicKey.AllowCredentials.Type.
type CredentialRequestOptionsPublicKeyAllowCredentialsType string

// CredentialRequestOptionsPublicKeyUserVerification defines model for CredentialRequestOptions.PublicKey.UserVerification.
type CredentialRequestOptionsPublicKeyUserVerification string

// Emails defines model for Emails.
type Emails = []struct {
	// Address The email address
	Address *openapi_types.Email `json:"address,omitempty"`

	// Id The ID of the email address
	Id *UUID4 `json:"id,omitempty"`

	// IsPrimary Indicates it's the primary email address.
	IsPrimary *bool `json:"is_primary,omitempty"`

	// IsVerified Indicated the email has been verified.
	IsVerified *bool `json:"is_verified,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    int32  `json:"code"`
	Message string `json:"message"`
}

// HankoConfiguration Public backend configuration options
type HankoConfiguration struct {
	// Account Controls the behavior regarding user account.
	Account *struct {
		// AllowDeletion Indicates the user account can be deleted by the current user.
		AllowDeletion *bool `json:"allow_deletion,omitempty"`

		// AllowSignup Indicates users are able to create new accounts.
		AllowSignup *bool `json:"allow_signup,omitempty"`
	} `json:"account,omitempty"`

	// Emails Controls the behavior regarding email addresses.
	Emails *struct {
		// RequireVerification Require email verification after account registration and prevent signing in with unverified email addresses. Also, email addresses can only be marked as primary when they have been verified before.
		RequireVerification *bool `json:"require_verification,omitempty"`
	} `json:"emails,omitempty"`

	// Password Configuration options concerning passwords
	Password *struct {
		// Enabled Indicates whether passwords are enabled or not
		Enabled *bool `json:"enabled,omitempty"`

		// MinPasswordLength Describes the minimum password length
		MinPasswordLength *float32 `json:"min_password_length,omitempty"`
	} `json:"password,omitempty"`
}

// JSONWebKey defines model for JSONWebKey.
type JSONWebKey struct {
	Alg *string `json:"alg,omitempty"`
	E   *string `json:"e,omitempty"`
	Kid *string `json:"kid,omitempty"`
	Kty *string `json:"kty,omitempty"`
	N   *string `json:"n,omitempty"`
	Use *string `json:"use,omitempty"`
}

// JSONWebKeySet defines model for JSONWebKeySet.
type JSONWebKeySet struct {
	Keys *[]JSONWebKey `json:"keys,omitempty"`
}

// Passcode Representation of a passcode
type Passcode struct {
	// CreatedAt Time of creation of the passcode
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id The ID of the passcode
	Id *UUID4 `json:"id,omitempty"`

	// Ttl Lifespan of a passcode in seconds
	Ttl *int `json:"ttl,omitempty"`
}

// Password The actual password, its `minLength` defaults to 8 but
// can be [configured](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config)
// through the `password.min_password_length` option.
type Password = string

// PublicKeyCredentialAssertionResponse WebAuthn API response to a navigator.credentials.get() call
type PublicKeyCredentialAssertionResponse struct {
	Id       *string `json:"id,omitempty"`
	RawId    *string `json:"rawId,omitempty"`
	Response *struct {
		AuthenticatorData *string `json:"authenticatorData,omitempty"`
		ClientDataJson    *string `json:"clientDataJson,omitempty"`
		Signature         *string `json:"signature,omitempty"`
		UserHandle        *string `json:"userHandle,omitempty"`
	} `json:"response,omitempty"`
	Type *PublicKeyCredentialAssertionResponseType `json:"type,omitempty"`
}

// PublicKeyCredentialAssertionResponseType defines model for PublicKeyCredentialAssertionResponse.Type.
type PublicKeyCredentialAssertionResponseType string

// PublicKeyCredentialAttestationResponse WebAuthn API response to a navigator.credentials.create() call
type PublicKeyCredentialAttestationResponse struct {
	Id       *string `json:"id,omitempty"`
	RawId    *string `json:"rawId,omitempty"`
	Response *struct {
		AttestationObject *string                                                     `json:"attestationObject,omitempty"`
		ClientDataJson    *string                                                     `json:"clientDataJson,omitempty"`
		Transports        *[]PublicKeyCredentialAttestationResponseResponseTransports `json:"transports,omitempty"`
	} `json:"response,omitempty"`
	Type *PublicKeyCredentialAttestationResponseType `json:"type,omitempty"`
}

// PublicKeyCredentialAttestationResponseResponseTransports defines model for PublicKeyCredentialAttestationResponse.Response.Transports.
type PublicKeyCredentialAttestationResponseResponseTransports string

// PublicKeyCredentialAttestationResponseType defines model for PublicKeyCredentialAttestationResponse.Type.
type PublicKeyCredentialAttestationResponseType string

// UUID4 defines model for UUID4.
type UUID4 = string

// User defines model for User.
type User struct {
	// CreatedAt Time of creation of the the user
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Email The email address of the user
	Email *openapi_types.Email `json:"email,omitempty"`

	// Id The ID of the user
	Id *UUID4 `json:"id,omitempty"`

	// UpdatedAt Time of last update of the user
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// WebauthnCredentials List of registered Webauthn credentials
	WebauthnCredentials *[]struct {
		// Id The ID of the Webauthn credential
		Id *string `json:"id,omitempty"`
	} `json:"webauthn_credentials,omitempty"`
}

// WebauthnCredentials A list of WebAuthn credentials
type WebauthnCredentials = []struct {
	// Aaguid The AAGUID of the authenticator.
	Aaguid *bool `json:"aaguid,omitempty"`

	// CreatedAt Time of creation of the credential
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Id The ID of the Webauthn credential
	Id *string `json:"id,omitempty"`

	// LastUsedAt The time when the credential was used last
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`

	// Name The name of the credential. Can be updated by the user.
	Name *string `json:"name,omitempty"`

	// PublicKey The public key assigned to the credential.
	PublicKey *bool `json:"public_key,omitempty"`

	// Transports Transports which may be used by the authenticator.
	Transports *[]WebauthnCredentialsTransports `json:"transports,omitempty"`
}

// WebauthnCredentialsTransports defines model for WebauthnCredentials.Transports.
type WebauthnCredentialsTransports string

// WebauthnLoginResponse Response after a successful login with webauthn
type WebauthnLoginResponse struct {
	CredentialId *string `json:"credential_id,omitempty"`
	UserId       *string `json:"user_id,omitempty"`
}

// XAuthToken Enable via [configuration](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config) option `session.enable_auth_token_header`
// for purposes of cross-domain communication between client and Hanko API.
type XAuthToken = string

// XSessionLifetime Contains the seconds until the session expires.
type XSessionLifetime = float32

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Conflict defines model for Conflict.
type Conflict = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// Gone defines model for Gone.
type Gone = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// RequestTimeOut defines model for RequestTimeOut.
type RequestTimeOut = Error

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnprocessableEntity defines model for Unprocessable Entity.
type UnprocessableEntity = Error

// CreateEmailJSONBody defines parameters for CreateEmail.
type CreateEmailJSONBody struct {
	Address openapi_types.Email `json:"address"`
}

// PasscodeFinalJSONBody defines parameters for PasscodeFinal.
type PasscodeFinalJSONBody struct {
	// Code The actual passcode from the email sent to the user during initialization,
	// a string of 6 decimal digits
	Code *string `json:"code,omitempty"`

	// Id The ID of the passcode
	Id *UUID4 `json:"id,omitempty"`
}

// PasscodeInitJSONBody defines parameters for PasscodeInit.
type PasscodeInitJSONBody struct {
	// EmailId The ID of the email address
	EmailId *UUID4 `json:"email_id,omitempty"`

	// UserId The ID of the user
	UserId *UUID4 `json:"user_id,omitempty"`
}

// PasswordJSONBody defines parameters for Password.
type PasswordJSONBody struct {
	// Password The actual password, its `minLength` defaults to 8 but
	// can be [configured](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config)
	// through the `password.min_password_length` option.
	Password Password `json:"password"`

	// UserId The ID of the user to create/set a password for
	UserId UUID4 `json:"user_id"`
}

// PasswordLoginJSONBody defines parameters for PasswordLogin.
type PasswordLoginJSONBody struct {
	// Password The actual password, its `minLength` defaults to 8 but
	// can be [configured](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config)
	// through the `password.min_password_length` option.
	Password Password `json:"password"`

	// UserId The ID of the user to perform a password login for
	UserId UUID4 `json:"user_id"`
}

// GetSamlAuthParams defines parameters for GetSamlAuth.
type GetSamlAuthParams struct {
	// Domain full qualified domain name to which a SAML service provider is registered
	Domain string `form:"domain" json:"domain"`

	// RedirectTo Base64url encoded string representing the URL the
	// [`/callback`](#tag/Enterprise-Features/operation/post-saml-callback) eventually redirects to after successful login
	// with the saml identity provider. It must match one of the allowed redirect URLs set in the backend
	// [configuration](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config)
	// through the `saml.allowed_redirect_urls`.
	RedirectTo string `form:"redirect_to" json:"redirect_to"`
}

// PostSamlCallbackFormdataBody defines parameters for PostSamlCallback.
type PostSamlCallbackFormdataBody struct {
	RelayState   *string `json:"RelayState,omitempty"`
	SAMLResponse *string `json:"SAMLResponse,omitempty"`
}

// GetSamlMetadataParams defines parameters for GetSamlMetadata.
type GetSamlMetadataParams struct {
	// Domain full qualified domain name to which a SAML service provider is registered
	Domain string `form:"domain" json:"domain"`

	// CertOnly Toggle to download the SAML service provider public certificate
	CertOnly *bool `form:"cert_only,omitempty" json:"cert_only,omitempty"`
}

// GetSamlProviderParams defines parameters for GetSamlProvider.
type GetSamlProviderParams struct {
	// Domain full qualified domain name to which a SAML service provider is registered
	Domain string `form:"domain" json:"domain"`
}

// ThirdPartyAuthParams defines parameters for ThirdPartyAuth.
type ThirdPartyAuthParams struct {
	// Provider The name of the third party provider to log in with. Only providers enabled in the
	// [configuration](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config)
	// via the `thirdparty.providers` option can be used. Requesting an unsupported provider results in a
	// redirect with error details in the location query.
	Provider ThirdPartyAuthParamsProvider `form:"provider" json:"provider"`

	// RedirectTo Base64url encoded string representing the URL the
	// [`/callback`](#tag/Third-Party/operation/thirdPartyCallback) eventually redirects to after successful login
	// with the third party provider. It must match one of the allowed redirect URLs set in the backend
	// [configuration](https://github.com/teamhanko/hanko/blob/main/backend/docs/Config.md#hanko-backend-config)
	// through the `third_party.allowed_redirect_urls`.
	RedirectTo string `form:"redirect_to" json:"redirect_to"`
}

// ThirdPartyAuthParamsProvider defines parameters for ThirdPartyAuth.
type ThirdPartyAuthParamsProvider string

// ThirdPartyCallbackParams defines parameters for ThirdPartyCallback.
type ThirdPartyCallbackParams struct {
	// Code The authorization code that can be exchanged for an access token and to retrieve user provider data
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// State The state
	State string `form:"state" json:"state"`

	// Error An error returned from the third party provider
	Error *string `form:"error,omitempty" json:"error,omitempty"`

	// ErrorDescription The description of the error that occurred (if any)
	ErrorDescription *string `form:"error_description,omitempty" json:"error_description,omitempty"`
}

// TokenJSONBody defines parameters for Token.
type TokenJSONBody struct {
	Value *string `json:"value,omitempty"`
}

// GetUserIdJSONBody defines parameters for GetUserId.
type GetUserIdJSONBody struct {
	Email *openapi_types.Email `json:"email,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	Email openapi_types.Email `json:"email"`
}

// UpdateCredentialJSONBody defines parameters for UpdateCredential.
type UpdateCredentialJSONBody struct {
	// Name A new credential name. Has no technical meaning, only serves as an identification aid for the user.
	Name *string `json:"name,omitempty"`
}

// WebauthnLoginInitJSONBody defines parameters for WebauthnLoginInit.
type WebauthnLoginInitJSONBody struct {
	// UserId The ID of the user on whose behalf WebAuthn login should be performed
	UserId *UUID4 `json:"user_id,omitempty"`
}

// CreateEmailJSONRequestBody defines body for CreateEmail for application/json ContentType.
type CreateEmailJSONRequestBody CreateEmailJSONBody

// PasscodeFinalJSONRequestBody defines body for PasscodeFinal for application/json ContentType.
type PasscodeFinalJSONRequestBody PasscodeFinalJSONBody

// PasscodeInitJSONRequestBody defines body for PasscodeInit for application/json ContentType.
type PasscodeInitJSONRequestBody PasscodeInitJSONBody

// PasswordJSONRequestBody defines body for Password for application/json ContentType.
type PasswordJSONRequestBody PasswordJSONBody

// PasswordLoginJSONRequestBody defines body for PasswordLogin for application/json ContentType.
type PasswordLoginJSONRequestBody PasswordLoginJSONBody

// PostSamlCallbackFormdataRequestBody defines body for PostSamlCallback for application/x-www-form-urlencoded ContentType.
type PostSamlCallbackFormdataRequestBody PostSamlCallbackFormdataBody

// TokenJSONRequestBody defines body for Token for application/json ContentType.
type TokenJSONRequestBody TokenJSONBody

// GetUserIdJSONRequestBody defines body for GetUserId for application/json ContentType.
type GetUserIdJSONRequestBody GetUserIdJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateCredentialJSONRequestBody defines body for UpdateCredential for application/json ContentType.
type UpdateCredentialJSONRequestBody UpdateCredentialJSONBody

// WebauthnLoginFinalJSONRequestBody defines body for WebauthnLoginFinal for application/json ContentType.
type WebauthnLoginFinalJSONRequestBody = PublicKeyCredentialAssertionResponse

// WebauthnLoginInitJSONRequestBody defines body for WebauthnLoginInit for application/json ContentType.
type WebauthnLoginInitJSONRequestBody WebauthnLoginInitJSONBody

// WebauthnRegFinalJSONRequestBody defines body for WebauthnRegFinal for application/json ContentType.
type WebauthnRegFinalJSONRequestBody = PublicKeyCredentialAttestationResponse

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Status request
	Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJwks request
	GetJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEmails request
	ListEmails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEmail request with any body
	CreateEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEmail(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEmail request
	DeleteEmail(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPrimaryEmail request
	SetPrimaryEmail(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IsUserAuthorized request
	IsUserAuthorized(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasscodeFinal request with any body
	PasscodeFinalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasscodeFinal(ctx context.Context, body PasscodeFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasscodeInit request with any body
	PasscodeInitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasscodeInit(ctx context.Context, body PasscodeInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Password request with any body
	PasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Password(ctx context.Context, body PasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasswordLogin request with any body
	PasswordLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasswordLogin(ctx context.Context, body PasswordLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlAuth request
	GetSamlAuth(ctx context.Context, params *GetSamlAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSamlCallback request with any body
	PostSamlCallbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSamlCallbackWithFormdataBody(ctx context.Context, body PostSamlCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlMetadata request
	GetSamlMetadata(ctx context.Context, params *GetSamlMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSamlProvider request
	GetSamlProvider(ctx context.Context, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThirdPartyAuth request
	ThirdPartyAuth(ctx context.Context, params *ThirdPartyAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ThirdPartyCallback request
	ThirdPartyCallback(ctx context.Context, params *ThirdPartyCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Token request with any body
	TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Token(ctx context.Context, body TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserId request with any body
	GetUserIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUserId(ctx context.Context, body GetUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUser request
	ListUser(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCredentials request
	ListCredentials(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredential request
	DeleteCredential(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCredential request with any body
	UpdateCredentialWithBody(ctx context.Context, id UUID4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCredential(ctx context.Context, id UUID4, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebauthnLoginFinal request with any body
	WebauthnLoginFinalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebauthnLoginFinal(ctx context.Context, body WebauthnLoginFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebauthnLoginInit request with any body
	WebauthnLoginInitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebauthnLoginInit(ctx context.Context, body WebauthnLoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebauthnRegFinal request with any body
	WebauthnRegFinalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WebauthnRegFinal(ctx context.Context, body WebauthnRegFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WebauthnRegInit request
	WebauthnRegInit(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJwks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJwksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEmails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEmailsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEmail(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEmail(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEmailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPrimaryEmail(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPrimaryEmailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IsUserAuthorized(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIsUserAuthorizedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasscodeFinalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasscodeFinalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasscodeFinal(ctx context.Context, body PasscodeFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasscodeFinalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasscodeInitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasscodeInitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasscodeInit(ctx context.Context, body PasscodeInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasscodeInitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Password(ctx context.Context, body PasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordLoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasswordLogin(ctx context.Context, body PasswordLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasswordLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlAuth(ctx context.Context, params *GetSamlAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlAuthRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSamlCallbackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSamlCallbackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSamlCallbackWithFormdataBody(ctx context.Context, body PostSamlCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSamlCallbackRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlMetadata(ctx context.Context, params *GetSamlMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSamlProvider(ctx context.Context, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSamlProviderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThirdPartyAuth(ctx context.Context, params *ThirdPartyAuthParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThirdPartyAuthRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ThirdPartyCallback(ctx context.Context, params *ThirdPartyCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewThirdPartyCallbackRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Token(ctx context.Context, body TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserIdWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserIdRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserId(ctx context.Context, body GetUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserIdRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUser(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCredentials(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCredentialsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredential(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCredentialWithBody(ctx context.Context, id UUID4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCredentialRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCredential(ctx context.Context, id UUID4, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCredentialRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnLoginFinalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnLoginFinalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnLoginFinal(ctx context.Context, body WebauthnLoginFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnLoginFinalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnLoginInitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnLoginInitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnLoginInit(ctx context.Context, body WebauthnLoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnLoginInitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnRegFinalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnRegFinalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnRegFinal(ctx context.Context, body WebauthnRegFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnRegFinalRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WebauthnRegInit(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWebauthnRegInitRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewStatusRequest generates requests for Status
func NewStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJwksRequest generates requests for GetJwks
func NewGetJwksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEmailsRequest generates requests for ListEmails
func NewListEmailsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEmailRequest calls the generic CreateEmail builder with application/json body
func NewCreateEmailRequest(server string, body CreateEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEmailRequestWithBody generates requests for CreateEmail with any type of body
func NewCreateEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEmailRequest generates requests for DeleteEmail
func NewDeleteEmailRequest(server string, id UUID4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPrimaryEmailRequest generates requests for SetPrimaryEmail
func NewSetPrimaryEmailRequest(server string, id UUID4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emails/%s/set_primary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIsUserAuthorizedRequest generates requests for IsUserAuthorized
func NewIsUserAuthorizedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasscodeFinalRequest calls the generic PasscodeFinal builder with application/json body
func NewPasscodeFinalRequest(server string, body PasscodeFinalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasscodeFinalRequestWithBody(server, "application/json", bodyReader)
}

// NewPasscodeFinalRequestWithBody generates requests for PasscodeFinal with any type of body
func NewPasscodeFinalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passcode/login/finalize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasscodeInitRequest calls the generic PasscodeInit builder with application/json body
func NewPasscodeInitRequest(server string, body PasscodeInitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasscodeInitRequestWithBody(server, "application/json", bodyReader)
}

// NewPasscodeInitRequestWithBody generates requests for PasscodeInit with any type of body
func NewPasscodeInitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passcode/login/initialize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordRequest calls the generic Password builder with application/json body
func NewPasswordRequest(server string, body PasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordRequestWithBody generates requests for Password with any type of body
func NewPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasswordLoginRequest calls the generic PasswordLogin builder with application/json body
func NewPasswordLoginRequest(server string, body PasswordLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasswordLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewPasswordLoginRequestWithBody generates requests for PasswordLogin with any type of body
func NewPasswordLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/password/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSamlAuthRequest generates requests for GetSamlAuth
func NewGetSamlAuthRequest(server string, params *GetSamlAuthParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saml/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, params.Domain); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_to", runtime.ParamLocationQuery, params.RedirectTo); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSamlCallbackRequestWithFormdataBody calls the generic PostSamlCallback builder with application/x-www-form-urlencoded body
func NewPostSamlCallbackRequestWithFormdataBody(server string, body PostSamlCallbackFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostSamlCallbackRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostSamlCallbackRequestWithBody generates requests for PostSamlCallback with any type of body
func NewPostSamlCallbackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saml/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSamlMetadataRequest generates requests for GetSamlMetadata
func NewGetSamlMetadataRequest(server string, params *GetSamlMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saml/metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, params.Domain); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.CertOnly != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_only", runtime.ParamLocationQuery, *params.CertOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSamlProviderRequest generates requests for GetSamlProvider
func NewGetSamlProviderRequest(server string, params *GetSamlProviderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/saml/provider")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, params.Domain); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewThirdPartyAuthRequest generates requests for ThirdPartyAuth
func NewThirdPartyAuthRequest(server string, params *ThirdPartyAuthParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thirdparty/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, params.Provider); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_to", runtime.ParamLocationQuery, params.RedirectTo); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewThirdPartyCallbackRequest generates requests for ThirdPartyCallback
func NewThirdPartyCallbackRequest(server string, params *ThirdPartyCallbackParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thirdparty/callback")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Code != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, params.State); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Error != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "error", runtime.ParamLocationQuery, *params.Error); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ErrorDescription != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "error_description", runtime.ParamLocationQuery, *params.ErrorDescription); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokenRequest calls the generic Token builder with application/json body
func NewTokenRequest(server string, body TokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewTokenRequestWithBody generates requests for Token with any type of body
func NewTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserIdRequest calls the generic GetUserId builder with application/json body
func NewGetUserIdRequest(server string, body GetUserIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUserIdRequestWithBody(server, "application/json", bodyReader)
}

// NewGetUserIdRequestWithBody generates requests for GetUserId with any type of body
func NewGetUserIdRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserRequest generates requests for ListUser
func NewListUserRequest(server string, id UUID4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCredentialsRequest generates requests for ListCredentials
func NewListCredentialsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCredentialRequest generates requests for DeleteCredential
func NewDeleteCredentialRequest(server string, id UUID4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCredentialRequest calls the generic UpdateCredential builder with application/json body
func NewUpdateCredentialRequest(server string, id UUID4, body UpdateCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCredentialRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCredentialRequestWithBody generates requests for UpdateCredential with any type of body
func NewUpdateCredentialRequestWithBody(server string, id UUID4, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebauthnLoginFinalRequest calls the generic WebauthnLoginFinal builder with application/json body
func NewWebauthnLoginFinalRequest(server string, body WebauthnLoginFinalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebauthnLoginFinalRequestWithBody(server, "application/json", bodyReader)
}

// NewWebauthnLoginFinalRequestWithBody generates requests for WebauthnLoginFinal with any type of body
func NewWebauthnLoginFinalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/login/finalize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebauthnLoginInitRequest calls the generic WebauthnLoginInit builder with application/json body
func NewWebauthnLoginInitRequest(server string, body WebauthnLoginInitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebauthnLoginInitRequestWithBody(server, "application/json", bodyReader)
}

// NewWebauthnLoginInitRequestWithBody generates requests for WebauthnLoginInit with any type of body
func NewWebauthnLoginInitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/login/initialize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebauthnRegFinalRequest calls the generic WebauthnRegFinal builder with application/json body
func NewWebauthnRegFinalRequest(server string, body WebauthnRegFinalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWebauthnRegFinalRequestWithBody(server, "application/json", bodyReader)
}

// NewWebauthnRegFinalRequestWithBody generates requests for WebauthnRegFinal with any type of body
func NewWebauthnRegFinalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/registration/finalize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWebauthnRegInitRequest generates requests for WebauthnRegInit
func NewWebauthnRegInitRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webauthn/registration/initialize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Status request
	StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetJwks request
	GetJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJwksResponse, error)

	// ListEmails request
	ListEmailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEmailsResponse, error)

	// CreateEmail request with any body
	CreateEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error)

	CreateEmailWithResponse(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error)

	// DeleteEmail request
	DeleteEmailWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*DeleteEmailResponse, error)

	// SetPrimaryEmail request
	SetPrimaryEmailWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*SetPrimaryEmailResponse, error)

	// Logout request
	LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// IsUserAuthorized request
	IsUserAuthorizedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsUserAuthorizedResponse, error)

	// PasscodeFinal request with any body
	PasscodeFinalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasscodeFinalResponse, error)

	PasscodeFinalWithResponse(ctx context.Context, body PasscodeFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*PasscodeFinalResponse, error)

	// PasscodeInit request with any body
	PasscodeInitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasscodeInitResponse, error)

	PasscodeInitWithResponse(ctx context.Context, body PasscodeInitJSONRequestBody, reqEditors ...RequestEditorFn) (*PasscodeInitResponse, error)

	// Password request with any body
	PasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordResponse, error)

	PasswordWithResponse(ctx context.Context, body PasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordResponse, error)

	// PasswordLogin request with any body
	PasswordLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordLoginResponse, error)

	PasswordLoginWithResponse(ctx context.Context, body PasswordLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordLoginResponse, error)

	// GetSamlAuth request
	GetSamlAuthWithResponse(ctx context.Context, params *GetSamlAuthParams, reqEditors ...RequestEditorFn) (*GetSamlAuthResponse, error)

	// PostSamlCallback request with any body
	PostSamlCallbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSamlCallbackResponse, error)

	PostSamlCallbackWithFormdataBodyWithResponse(ctx context.Context, body PostSamlCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostSamlCallbackResponse, error)

	// GetSamlMetadata request
	GetSamlMetadataWithResponse(ctx context.Context, params *GetSamlMetadataParams, reqEditors ...RequestEditorFn) (*GetSamlMetadataResponse, error)

	// GetSamlProvider request
	GetSamlProviderWithResponse(ctx context.Context, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error)

	// ThirdPartyAuth request
	ThirdPartyAuthWithResponse(ctx context.Context, params *ThirdPartyAuthParams, reqEditors ...RequestEditorFn) (*ThirdPartyAuthResponse, error)

	// ThirdPartyCallback request
	ThirdPartyCallbackWithResponse(ctx context.Context, params *ThirdPartyCallbackParams, reqEditors ...RequestEditorFn) (*ThirdPartyCallbackResponse, error)

	// Token request with any body
	TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	TokenWithResponse(ctx context.Context, body TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserId request with any body
	GetUserIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUserIdResponse, error)

	GetUserIdWithResponse(ctx context.Context, body GetUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUserIdResponse, error)

	// CreateUser request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// ListUser request
	ListUserWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*ListUserResponse, error)

	// ListCredentials request
	ListCredentialsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCredentialsResponse, error)

	// DeleteCredential request
	DeleteCredentialWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*DeleteCredentialResponse, error)

	// UpdateCredential request with any body
	UpdateCredentialWithBodyWithResponse(ctx context.Context, id UUID4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCredentialResponse, error)

	UpdateCredentialWithResponse(ctx context.Context, id UUID4, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCredentialResponse, error)

	// WebauthnLoginFinal request with any body
	WebauthnLoginFinalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebauthnLoginFinalResponse, error)

	WebauthnLoginFinalWithResponse(ctx context.Context, body WebauthnLoginFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*WebauthnLoginFinalResponse, error)

	// WebauthnLoginInit request with any body
	WebauthnLoginInitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebauthnLoginInitResponse, error)

	WebauthnLoginInitWithResponse(ctx context.Context, body WebauthnLoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*WebauthnLoginInitResponse, error)

	// WebauthnRegFinal request with any body
	WebauthnRegFinalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebauthnRegFinalResponse, error)

	WebauthnRegFinalWithResponse(ctx context.Context, body WebauthnRegFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*WebauthnRegFinalResponse, error)

	// WebauthnRegInit request
	WebauthnRegInitWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WebauthnRegInitResponse, error)
}

type StatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HankoConfiguration
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJwksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JSONWebKeySet
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetJwksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJwksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEmailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Emails
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListEmailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEmailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPrimaryEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetPrimaryEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPrimaryEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IsUserAuthorizedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The id of the current user
		Id *UUID4 `json:"id,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r IsUserAuthorizedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IsUserAuthorizedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasscodeFinalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Passcode
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON408      *Error
	JSON410      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PasscodeFinalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasscodeFinalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasscodeInitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Passcode
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PasscodeInitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasscodeInitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasswordLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PasswordLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasswordLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSamlAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSamlCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostSamlCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSamlCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetSamlMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSamlProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AttributeMap *struct {
			Birthdate         *string `json:"birthdate,omitempty"`
			Email             *string `json:"email,omitempty"`
			EmailVerified     *string `json:"email_verified,omitempty"`
			FamilyName        *string `json:"family_name,omitempty"`
			Gender            *string `json:"gender,omitempty"`
			GivenName         *string `json:"given_name,omitempty"`
			Locale            *string `json:"locale,omitempty"`
			MiddleName        *string `json:"middle_name,omitempty"`
			Name              *string `json:"name,omitempty"`
			Nickname          *string `json:"nickname,omitempty"`
			Phone             *string `json:"phone,omitempty"`
			PhoneVerified     *string `json:"phone_verified,omitempty"`
			Picture           *string `json:"picture,omitempty"`
			PreferredUsername *string `json:"preferred_username,omitempty"`
			Profile           *string `json:"profile,omitempty"`
			UpdatedAt         *string `json:"updated_at,omitempty"`
			Website           *string `json:"website,omitempty"`
			ZoneInfo          *string `json:"zone_info,omitempty"`
		} `json:"attribute_map,omitempty"`
		Domain                *string `json:"domain,omitempty"`
		Enabled               *bool   `json:"enabled,omitempty"`
		MetadataUrl           *string `json:"metadata_url,omitempty"`
		Name                  *string `json:"name,omitempty"`
		SkipEmailVerification *bool   `json:"skip_email_verification,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetSamlProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThirdPartyAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ThirdPartyAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThirdPartyAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ThirdPartyCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ThirdPartyCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ThirdPartyCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// UserId The ID of the user on whose behalf the token was exchanged.
		UserId *UUID4 `json:"user_id,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON422 *Error
	JSON429 *Error
}

// Status returns HTTPResponse.Status
func (r TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		EmailId               *UUID4 `json:"email_id,omitempty"`
		HasWebauthnCredential *bool  `json:"has_webauthn_credential,omitempty"`
		Id                    *UUID4 `json:"id,omitempty"`
		Verified              *bool  `json:"verified,omitempty"`
	}
	JSON400 *Error
	JSON404 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r GetUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateUserResponseObject
	JSON400      *Error
	JSON403      *Error
	JSON409      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *Error
	JSON403      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebauthnCredentials
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebauthnLoginFinalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebauthnLoginResponse
	JSON400      *Error
	JSON401      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WebauthnLoginFinalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebauthnLoginFinalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebauthnLoginInitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialRequestOptions
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WebauthnLoginInitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebauthnLoginInitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebauthnRegFinalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CredentialId The ID of the created credential
		CredentialId *string `json:"credential_id,omitempty"`

		// UserId The ID of the user on whose behalf a credential was created
		UserId *UUID4 `json:"user_id,omitempty"`
	}
	JSON400 *Error
	JSON500 *Error
}

// Status returns HTTPResponse.Status
func (r WebauthnRegFinalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebauthnRegFinalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WebauthnRegInitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialCreationOptions
	JSON400      *Error
	JSON422      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WebauthnRegInitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WebauthnRegInitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// StatusWithResponse request returning *StatusResponse
func (c *ClientWithResponses) StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResponse, error) {
	rsp, err := c.Status(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetJwksWithResponse request returning *GetJwksResponse
func (c *ClientWithResponses) GetJwksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJwksResponse, error) {
	rsp, err := c.GetJwks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJwksResponse(rsp)
}

// ListEmailsWithResponse request returning *ListEmailsResponse
func (c *ClientWithResponses) ListEmailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEmailsResponse, error) {
	rsp, err := c.ListEmails(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEmailsResponse(rsp)
}

// CreateEmailWithBodyWithResponse request with arbitrary body returning *CreateEmailResponse
func (c *ClientWithResponses) CreateEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error) {
	rsp, err := c.CreateEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmailResponse(rsp)
}

func (c *ClientWithResponses) CreateEmailWithResponse(ctx context.Context, body CreateEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEmailResponse, error) {
	rsp, err := c.CreateEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEmailResponse(rsp)
}

// DeleteEmailWithResponse request returning *DeleteEmailResponse
func (c *ClientWithResponses) DeleteEmailWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*DeleteEmailResponse, error) {
	rsp, err := c.DeleteEmail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEmailResponse(rsp)
}

// SetPrimaryEmailWithResponse request returning *SetPrimaryEmailResponse
func (c *ClientWithResponses) SetPrimaryEmailWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*SetPrimaryEmailResponse, error) {
	rsp, err := c.SetPrimaryEmail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPrimaryEmailResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// IsUserAuthorizedWithResponse request returning *IsUserAuthorizedResponse
func (c *ClientWithResponses) IsUserAuthorizedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IsUserAuthorizedResponse, error) {
	rsp, err := c.IsUserAuthorized(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIsUserAuthorizedResponse(rsp)
}

// PasscodeFinalWithBodyWithResponse request with arbitrary body returning *PasscodeFinalResponse
func (c *ClientWithResponses) PasscodeFinalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasscodeFinalResponse, error) {
	rsp, err := c.PasscodeFinalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasscodeFinalResponse(rsp)
}

func (c *ClientWithResponses) PasscodeFinalWithResponse(ctx context.Context, body PasscodeFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*PasscodeFinalResponse, error) {
	rsp, err := c.PasscodeFinal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasscodeFinalResponse(rsp)
}

// PasscodeInitWithBodyWithResponse request with arbitrary body returning *PasscodeInitResponse
func (c *ClientWithResponses) PasscodeInitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasscodeInitResponse, error) {
	rsp, err := c.PasscodeInitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasscodeInitResponse(rsp)
}

func (c *ClientWithResponses) PasscodeInitWithResponse(ctx context.Context, body PasscodeInitJSONRequestBody, reqEditors ...RequestEditorFn) (*PasscodeInitResponse, error) {
	rsp, err := c.PasscodeInit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasscodeInitResponse(rsp)
}

// PasswordWithBodyWithResponse request with arbitrary body returning *PasswordResponse
func (c *ClientWithResponses) PasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordResponse, error) {
	rsp, err := c.PasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordResponse(rsp)
}

func (c *ClientWithResponses) PasswordWithResponse(ctx context.Context, body PasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordResponse, error) {
	rsp, err := c.Password(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordResponse(rsp)
}

// PasswordLoginWithBodyWithResponse request with arbitrary body returning *PasswordLoginResponse
func (c *ClientWithResponses) PasswordLoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasswordLoginResponse, error) {
	rsp, err := c.PasswordLoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordLoginResponse(rsp)
}

func (c *ClientWithResponses) PasswordLoginWithResponse(ctx context.Context, body PasswordLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PasswordLoginResponse, error) {
	rsp, err := c.PasswordLogin(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasswordLoginResponse(rsp)
}

// GetSamlAuthWithResponse request returning *GetSamlAuthResponse
func (c *ClientWithResponses) GetSamlAuthWithResponse(ctx context.Context, params *GetSamlAuthParams, reqEditors ...RequestEditorFn) (*GetSamlAuthResponse, error) {
	rsp, err := c.GetSamlAuth(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlAuthResponse(rsp)
}

// PostSamlCallbackWithBodyWithResponse request with arbitrary body returning *PostSamlCallbackResponse
func (c *ClientWithResponses) PostSamlCallbackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSamlCallbackResponse, error) {
	rsp, err := c.PostSamlCallbackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSamlCallbackResponse(rsp)
}

func (c *ClientWithResponses) PostSamlCallbackWithFormdataBodyWithResponse(ctx context.Context, body PostSamlCallbackFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostSamlCallbackResponse, error) {
	rsp, err := c.PostSamlCallbackWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSamlCallbackResponse(rsp)
}

// GetSamlMetadataWithResponse request returning *GetSamlMetadataResponse
func (c *ClientWithResponses) GetSamlMetadataWithResponse(ctx context.Context, params *GetSamlMetadataParams, reqEditors ...RequestEditorFn) (*GetSamlMetadataResponse, error) {
	rsp, err := c.GetSamlMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlMetadataResponse(rsp)
}

// GetSamlProviderWithResponse request returning *GetSamlProviderResponse
func (c *ClientWithResponses) GetSamlProviderWithResponse(ctx context.Context, params *GetSamlProviderParams, reqEditors ...RequestEditorFn) (*GetSamlProviderResponse, error) {
	rsp, err := c.GetSamlProvider(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSamlProviderResponse(rsp)
}

// ThirdPartyAuthWithResponse request returning *ThirdPartyAuthResponse
func (c *ClientWithResponses) ThirdPartyAuthWithResponse(ctx context.Context, params *ThirdPartyAuthParams, reqEditors ...RequestEditorFn) (*ThirdPartyAuthResponse, error) {
	rsp, err := c.ThirdPartyAuth(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThirdPartyAuthResponse(rsp)
}

// ThirdPartyCallbackWithResponse request returning *ThirdPartyCallbackResponse
func (c *ClientWithResponses) ThirdPartyCallbackWithResponse(ctx context.Context, params *ThirdPartyCallbackParams, reqEditors ...RequestEditorFn) (*ThirdPartyCallbackResponse, error) {
	rsp, err := c.ThirdPartyCallback(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseThirdPartyCallbackResponse(rsp)
}

// TokenWithBodyWithResponse request with arbitrary body returning *TokenResponse
func (c *ClientWithResponses) TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

func (c *ClientWithResponses) TokenWithResponse(ctx context.Context, body TokenJSONRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.Token(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserIdWithBodyWithResponse request with arbitrary body returning *GetUserIdResponse
func (c *ClientWithResponses) GetUserIdWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUserIdResponse, error) {
	rsp, err := c.GetUserIdWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserIdResponse(rsp)
}

func (c *ClientWithResponses) GetUserIdWithResponse(ctx context.Context, body GetUserIdJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUserIdResponse, error) {
	rsp, err := c.GetUserId(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserIdResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// ListUserWithResponse request returning *ListUserResponse
func (c *ClientWithResponses) ListUserWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*ListUserResponse, error) {
	rsp, err := c.ListUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserResponse(rsp)
}

// ListCredentialsWithResponse request returning *ListCredentialsResponse
func (c *ClientWithResponses) ListCredentialsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCredentialsResponse, error) {
	rsp, err := c.ListCredentials(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCredentialsResponse(rsp)
}

// DeleteCredentialWithResponse request returning *DeleteCredentialResponse
func (c *ClientWithResponses) DeleteCredentialWithResponse(ctx context.Context, id UUID4, reqEditors ...RequestEditorFn) (*DeleteCredentialResponse, error) {
	rsp, err := c.DeleteCredential(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialResponse(rsp)
}

// UpdateCredentialWithBodyWithResponse request with arbitrary body returning *UpdateCredentialResponse
func (c *ClientWithResponses) UpdateCredentialWithBodyWithResponse(ctx context.Context, id UUID4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCredentialResponse, error) {
	rsp, err := c.UpdateCredentialWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCredentialResponse(rsp)
}

func (c *ClientWithResponses) UpdateCredentialWithResponse(ctx context.Context, id UUID4, body UpdateCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCredentialResponse, error) {
	rsp, err := c.UpdateCredential(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCredentialResponse(rsp)
}

// WebauthnLoginFinalWithBodyWithResponse request with arbitrary body returning *WebauthnLoginFinalResponse
func (c *ClientWithResponses) WebauthnLoginFinalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebauthnLoginFinalResponse, error) {
	rsp, err := c.WebauthnLoginFinalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnLoginFinalResponse(rsp)
}

func (c *ClientWithResponses) WebauthnLoginFinalWithResponse(ctx context.Context, body WebauthnLoginFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*WebauthnLoginFinalResponse, error) {
	rsp, err := c.WebauthnLoginFinal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnLoginFinalResponse(rsp)
}

// WebauthnLoginInitWithBodyWithResponse request with arbitrary body returning *WebauthnLoginInitResponse
func (c *ClientWithResponses) WebauthnLoginInitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebauthnLoginInitResponse, error) {
	rsp, err := c.WebauthnLoginInitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnLoginInitResponse(rsp)
}

func (c *ClientWithResponses) WebauthnLoginInitWithResponse(ctx context.Context, body WebauthnLoginInitJSONRequestBody, reqEditors ...RequestEditorFn) (*WebauthnLoginInitResponse, error) {
	rsp, err := c.WebauthnLoginInit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnLoginInitResponse(rsp)
}

// WebauthnRegFinalWithBodyWithResponse request with arbitrary body returning *WebauthnRegFinalResponse
func (c *ClientWithResponses) WebauthnRegFinalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WebauthnRegFinalResponse, error) {
	rsp, err := c.WebauthnRegFinalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnRegFinalResponse(rsp)
}

func (c *ClientWithResponses) WebauthnRegFinalWithResponse(ctx context.Context, body WebauthnRegFinalJSONRequestBody, reqEditors ...RequestEditorFn) (*WebauthnRegFinalResponse, error) {
	rsp, err := c.WebauthnRegFinal(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnRegFinalResponse(rsp)
}

// WebauthnRegInitWithResponse request returning *WebauthnRegInitResponse
func (c *ClientWithResponses) WebauthnRegInitWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WebauthnRegInitResponse, error) {
	rsp, err := c.WebauthnRegInit(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWebauthnRegInitResponse(rsp)
}

// ParseStatusResponse parses an HTTP response from a StatusWithResponse call
func ParseStatusResponse(rsp *http.Response) (*StatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HankoConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetJwksResponse parses an HTTP response from a GetJwksWithResponse call
func ParseGetJwksResponse(rsp *http.Response) (*GetJwksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJwksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JSONWebKeySet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEmailsResponse parses an HTTP response from a ListEmailsWithResponse call
func ParseListEmailsResponse(rsp *http.Response) (*ListEmailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEmailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Emails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEmailResponse parses an HTTP response from a CreateEmailWithResponse call
func ParseCreateEmailResponse(rsp *http.Response) (*CreateEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEmailResponse parses an HTTP response from a DeleteEmailWithResponse call
func ParseDeleteEmailResponse(rsp *http.Response) (*DeleteEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetPrimaryEmailResponse parses an HTTP response from a SetPrimaryEmailWithResponse call
func ParseSetPrimaryEmailResponse(rsp *http.Response) (*SetPrimaryEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPrimaryEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIsUserAuthorizedResponse parses an HTTP response from a IsUserAuthorizedWithResponse call
func ParseIsUserAuthorizedResponse(rsp *http.Response) (*IsUserAuthorizedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IsUserAuthorizedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The id of the current user
			Id *UUID4 `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasscodeFinalResponse parses an HTTP response from a PasscodeFinalWithResponse call
func ParsePasscodeFinalResponse(rsp *http.Response) (*PasscodeFinalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasscodeFinalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Passcode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasscodeInitResponse parses an HTTP response from a PasscodeInitWithResponse call
func ParsePasscodeInitResponse(rsp *http.Response) (*PasscodeInitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasscodeInitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Passcode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordResponse parses an HTTP response from a PasswordWithResponse call
func ParsePasswordResponse(rsp *http.Response) (*PasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePasswordLoginResponse parses an HTTP response from a PasswordLoginWithResponse call
func ParsePasswordLoginResponse(rsp *http.Response) (*PasswordLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasswordLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSamlAuthResponse parses an HTTP response from a GetSamlAuthWithResponse call
func ParseGetSamlAuthResponse(rsp *http.Response) (*GetSamlAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostSamlCallbackResponse parses an HTTP response from a PostSamlCallbackWithResponse call
func ParsePostSamlCallbackResponse(rsp *http.Response) (*PostSamlCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSamlCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSamlMetadataResponse parses an HTTP response from a GetSamlMetadataWithResponse call
func ParseGetSamlMetadataResponse(rsp *http.Response) (*GetSamlMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetSamlProviderResponse parses an HTTP response from a GetSamlProviderWithResponse call
func ParseGetSamlProviderResponse(rsp *http.Response) (*GetSamlProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSamlProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AttributeMap *struct {
				Birthdate         *string `json:"birthdate,omitempty"`
				Email             *string `json:"email,omitempty"`
				EmailVerified     *string `json:"email_verified,omitempty"`
				FamilyName        *string `json:"family_name,omitempty"`
				Gender            *string `json:"gender,omitempty"`
				GivenName         *string `json:"given_name,omitempty"`
				Locale            *string `json:"locale,omitempty"`
				MiddleName        *string `json:"middle_name,omitempty"`
				Name              *string `json:"name,omitempty"`
				Nickname          *string `json:"nickname,omitempty"`
				Phone             *string `json:"phone,omitempty"`
				PhoneVerified     *string `json:"phone_verified,omitempty"`
				Picture           *string `json:"picture,omitempty"`
				PreferredUsername *string `json:"preferred_username,omitempty"`
				Profile           *string `json:"profile,omitempty"`
				UpdatedAt         *string `json:"updated_at,omitempty"`
				Website           *string `json:"website,omitempty"`
				ZoneInfo          *string `json:"zone_info,omitempty"`
			} `json:"attribute_map,omitempty"`
			Domain                *string `json:"domain,omitempty"`
			Enabled               *bool   `json:"enabled,omitempty"`
			MetadataUrl           *string `json:"metadata_url,omitempty"`
			Name                  *string `json:"name,omitempty"`
			SkipEmailVerification *bool   `json:"skip_email_verification,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseThirdPartyAuthResponse parses an HTTP response from a ThirdPartyAuthWithResponse call
func ParseThirdPartyAuthResponse(rsp *http.Response) (*ThirdPartyAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThirdPartyAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseThirdPartyCallbackResponse parses an HTTP response from a ThirdPartyCallbackWithResponse call
func ParseThirdPartyCallbackResponse(rsp *http.Response) (*ThirdPartyCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ThirdPartyCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTokenResponse parses an HTTP response from a TokenWithResponse call
func ParseTokenResponse(rsp *http.Response) (*TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// UserId The ID of the user on whose behalf the token was exchanged.
			UserId *UUID4 `json:"user_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserIdResponse parses an HTTP response from a GetUserIdWithResponse call
func ParseGetUserIdResponse(rsp *http.Response) (*GetUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			EmailId               *UUID4 `json:"email_id,omitempty"`
			HasWebauthnCredential *bool  `json:"has_webauthn_credential,omitempty"`
			Id                    *UUID4 `json:"id,omitempty"`
			Verified              *bool  `json:"verified,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateUserResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserResponse parses an HTTP response from a ListUserWithResponse call
func ParseListUserResponse(rsp *http.Response) (*ListUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCredentialsResponse parses an HTTP response from a ListCredentialsWithResponse call
func ParseListCredentialsResponse(rsp *http.Response) (*ListCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebauthnCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCredentialResponse parses an HTTP response from a DeleteCredentialWithResponse call
func ParseDeleteCredentialResponse(rsp *http.Response) (*DeleteCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCredentialResponse parses an HTTP response from a UpdateCredentialWithResponse call
func ParseUpdateCredentialResponse(rsp *http.Response) (*UpdateCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebauthnLoginFinalResponse parses an HTTP response from a WebauthnLoginFinalWithResponse call
func ParseWebauthnLoginFinalResponse(rsp *http.Response) (*WebauthnLoginFinalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebauthnLoginFinalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebauthnLoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebauthnLoginInitResponse parses an HTTP response from a WebauthnLoginInitWithResponse call
func ParseWebauthnLoginInitResponse(rsp *http.Response) (*WebauthnLoginInitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebauthnLoginInitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialRequestOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebauthnRegFinalResponse parses an HTTP response from a WebauthnRegFinalWithResponse call
func ParseWebauthnRegFinalResponse(rsp *http.Response) (*WebauthnRegFinalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebauthnRegFinalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CredentialId The ID of the created credential
			CredentialId *string `json:"credential_id,omitempty"`

			// UserId The ID of the user on whose behalf a credential was created
			UserId *UUID4 `json:"user_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWebauthnRegInitResponse parses an HTTP response from a WebauthnRegInitWithResponse call
func ParseWebauthnRegInitResponse(rsp *http.Response) (*WebauthnRegInitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WebauthnRegInitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialCreationOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
